<!doctype html>
<html>
  <head>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta charset="utf-8">
    <title>Fatigue Self-Report</title>
    <style>
      body { font-family: Arial, sans-serif; margin:0; padding:20px; text-align:center; }
      #container { max-width:500px; margin:0 auto; }
      h1 { font-size:1.6rem; margin-bottom:8px; }
      #participantRow { margin: 12px 0; }
      input[type="text"] { font-size:1rem; padding:8px; width:70%; }
      button.big { font-size:1.25rem; padding:16px 24px; margin:10px auto; width:85%; display:block; }
      #promptModal {
        position:fixed; left:0; right:0; top:0; bottom:0;
        background:rgba(0,0,0,0.6); display:none; align-items:center; justify-content:center;
      }
      #promptInner {
        background:white; padding:20px; border-radius:8px; width:90%; max-width:420px;
      }
      #status { margin-top:12px; color:green; font-size:0.95rem; }
    </style>
  </head>
  <body>
    <div id="container">
      <h1>Fatigue Self-Report</h1>
      <p>Tap <strong>Start</strong>, then rate your fatigue every <span id="intervalLabel">15</span> seconds on a scale of 1 (not fatigued) to 7 (completely exhausted).</p>

      <div id="participantRow">
        <input id="participantId" placeholder="Participant ID (optional)" />
        <button id="startBtn" class="big">Start Session</button>
      </div>

      <p id="status"></p>
    </div>

    <!-- Prompt Modal -->
    <div id="promptModal">
      <div id="promptInner">
        <h2>Rate Your Fatigue</h2>
        <div id="ratingButtons"></div>
        <p style="font-size:0.9rem; margin-top:8px">You have <span id="respTimer">10</span>s to respond</p>
      </div>
    </div>

    <script>
      // CONFIG
      const INTERVAL_MS = 15 * 1000;   // 15 seconds
      const RESPONSE_WINDOW_SEC = 10;

      // state
      let respCountdownTimer = null;
      let participantId = '';
      let responded = false;

      // build fatigue scale buttons (1–7)
      window.addEventListener('load', () => {
        const btnContainer = document.getElementById('ratingButtons');
        for (let i = 1; i <= 7; i++) {
          const btn = document.createElement('button');
          btn.className = 'big';
          btn.innerText = i;
          btn.onclick = () => respondAndClose(i);
          btnContainer.appendChild(btn);
        }
      });

      // Start button
      document.getElementById('startBtn').addEventListener('click', () => {
        participantId = document.getElementById('participantId').value.trim();
        schedulePrompt(0);                 // first prompt immediately
        setInterval(() => schedulePrompt(0), INTERVAL_MS);
        document.getElementById('status').innerText = 'Session started. Waiting for prompts...';
        document.getElementById('startBtn').disabled = true;
      });

      function schedulePrompt(delayMs) {
        setTimeout(() => {
          showPromptModal();
          playBeep();
          startRespCountdown(RESPONSE_WINDOW_SEC);
        }, delayMs);
      }

      function showPromptModal() {
        document.getElementById('promptModal').style.display = 'flex';
      }
      function hidePromptModal() {
        document.getElementById('promptModal').style.display = 'none';
      }

      function respondAndClose(responseLevel) {
        if (responded) return;
        responded = true;

        manualLog(responseLevel);
        hidePromptModal();
        stopRespCountdown();
        setTimeout(() => { responded = false; }, 100);
      }

      function manualLog(responseLevel) {
        const clientTs = new Date().toISOString();
        if (navigator.onLine) {
          google.script.run.withSuccessHandler(() => {
            document.getElementById('status').innerText = `Logged: ${responseLevel} (${clientTs})`;
          }).withFailureHandler(err => {
            queueEntry(responseLevel, clientTs);
            document.getElementById('status').innerText = `Saved offline (will sync): ${responseLevel}`;
          }).logFatigue(responseLevel, participantId, clientTs);
        } else {
          queueEntry(responseLevel, clientTs);
          document.getElementById('status').innerText = `Offline — saved locally: ${responseLevel}`;
        }
      }

      // beep
      function playBeep() {
        try {
          const ctx = new (window.AudioContext || window.webkitAudioContext)();
          const o = ctx.createOscillator();
          const g = ctx.createGain();
          o.type = 'sine';
          o.frequency.value = 880;
          g.gain.value = 0.05;
          o.connect(g);
          g.connect(ctx.destination);
          o.start();
          setTimeout(()=>{ o.stop(); ctx.close(); }, 300);
        } catch (e) {}
      }

      // countdown
      function startRespCountdown(seconds) {
        stopRespCountdown();
        let sec = seconds;
        const el = document.getElementById('respTimer');
        el.innerText = sec;
        respCountdownTimer = setInterval(() => {
          sec--;
          el.innerText = sec;
          if (sec <= 0) {
            clearInterval(respCountdownTimer);
            respCountdownTimer = null;
            respondAndClose(1); // default = "Not Fatigued"
          }
        }, 1000);
      }
      function stopRespCountdown() {
        if (respCountdownTimer) { clearInterval(respCountdownTimer); respCountdownTimer = null; }
      }

      // queue helpers
      function queueEntry(responseLevel, clientTs) {
        const q = JSON.parse(localStorage.getItem('fatigueQueue') || '[]');
        q.push({ response: responseLevel, ts: clientTs, pid: participantId || '' });
        localStorage.setItem('fatigueQueue', JSON.stringify(q));
      }
    </script>
  </body>
</html>